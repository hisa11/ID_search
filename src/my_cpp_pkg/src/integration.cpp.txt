#include "integration.hpp"
#include <chrono>
#include <sstream>
#include <algorithm>
#include <numeric>
#include <thread>

// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
IntegratedCommunicationSystem::IntegratedCommunicationSystem(
    const std::string& node_name, const std::vector<std::shared_ptr<SerialCommunication>>& serial_comms, bool auto_discover)
    : rclcpp::Node(node_name), self_node_name_(node_name), serial_comms_(serial_comms),
      shutdown_flag_(false), auto_discover_enabled_(auto_discover),
      random_engine_(std::chrono::high_resolution_clock::now().time_since_epoch().count()),
      distribution_(1, INT64_MAX)
{
    server_ = this->create_service<my_cpp_pkg::srv::DataExchange>(
        self_node_name_,
        std::bind(&IntegratedCommunicationSystem::handle_request, this, std::placeholders::_1, std::placeholders::_2));
        
    for(const auto& dev : serial_comms_) {
        dev->setReceiveCallback([this, port=dev->getPort()](const std::string& data){
            this->handle_serial_data(port, data);
        });
        dev->startReceiving();
    }
    worker_thread_ = std::thread([this](){ this->processRequestQueue(); });
    
    setupAutomaticMicrocontrollerRelay();

    // åˆæœŸã®ãƒãƒ¼ãƒ‰çŠ¶æ…‹ã¨ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆçŠ¶æ…‹ã‚’è¨˜éŒ²
    {
        std::lock_guard<std::mutex> lock(monitoring_mutex_);
        last_known_nodes_ = this->get_node_names();
        for(const auto& dev : serial_comms_) {
            last_known_serial_ports_.push_back(dev->getPort());
        }
    }

    // è‡ªå‹•æ¢ç´¢æ©Ÿèƒ½ãŒæœ‰åŠ¹ãªå ´åˆã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§æ¢ç´¢ã‚’é–‹å§‹
    if (auto_discover_enabled_) {
        std::thread discovery_thread(&IntegratedCommunicationSystem::startAutoDiscovery, this, 2000, 3000);
        discovery_thread.detach();
        
        // å®šæœŸçš„ãªãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚‚é–‹å§‹
        monitoring_enabled_ = true;
        monitoring_thread_ = std::thread(&IntegratedCommunicationSystem::monitoringLoop, this);
    }
}

IntegratedCommunicationSystem::~IntegratedCommunicationSystem()
{
    shutdown_flag_ = true;
    monitoring_enabled_ = false;
    
    queue_cv_.notify_all();
    if (worker_thread_.joinable()) worker_thread_.join();
    if (monitoring_thread_.joinable()) monitoring_thread_.join();
}

void IntegratedCommunicationSystem::setDataHandler(DataHandlerCallback callback) { data_handler_callback_ = callback; }

std::vector<std::string> IntegratedCommunicationSystem::discoverMicrocontrollerIDs(int timeout_ms)
{
    return discoverMicrocontrollerIDs(timeout_ms, true); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚¯ãƒªã‚¢ã™ã‚‹
}

std::vector<std::string> IntegratedCommunicationSystem::discoverMicrocontrollerIDs(int timeout_ms, bool clear_existing)
{
    RCLCPP_INFO(this->get_logger(), "ğŸ” ãƒã‚¤ã‚³ãƒ³æ¢ç´¢ã‚’é–‹å§‹ã—ã¾ã™ (timeout: %dms, clear_existing: %s)", 
                timeout_ms, clear_existing ? "true" : "false");
    
    discovery_promise_ = std::make_shared<std::promise<bool>>();
    auto future = discovery_promise_->get_future();
    
    // æ—¢å­˜ã®ãƒãƒƒãƒ—ã‚’ä¸€æ™‚çš„ã«ä¿å­˜
    std::vector<std::string> previous_microcontrollers;
    {
        std::lock_guard<std::mutex> lock(discovery_mutex_);
        previous_microcontrollers = discovered_microcontrollers_;
        if (clear_existing) {
            discovered_microcontrollers_.clear();
            microcontroller_device_map_.clear(); 
        }
    }
    
    // ãƒã‚¤ã‚³ãƒ³æ¢ç´¢ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡
    std::string id_request_command = "1," + self_node_name_ + ",0,|";
    int successful_sends = 0;
    
    for(auto& dev : serial_comms_) {
        if (dev && dev->isOpen()) {
            RCLCPP_INFO(this->get_logger(), "  ğŸ“¡ Sending discovery command to %s", dev->getPort().c_str());
            RCLCPP_INFO(this->get_logger(), "    Command: '%s'", id_request_command.c_str());
            if (dev->sendRaw(id_request_command)) {
                successful_sends++;
                RCLCPP_INFO(this->get_logger(), "    âœ… Command sent successfully");
            } else {
                RCLCPP_WARN(this->get_logger(), "  âš ï¸ Failed to send discovery command to %s", dev->getPort().c_str());
            }
        } else {
            RCLCPP_WARN(this->get_logger(), "  âŒ Device %s is not connected", dev ? dev->getPort().c_str() : "unknown");
        }
    }
    
    if (successful_sends == 0) {
        RCLCPP_ERROR(this->get_logger(), "âŒ No devices available for discovery");
        discovery_promise_ = nullptr;
        return getDiscoveredMicrocontrollers();
    }
    
    RCLCPP_INFO(this->get_logger(), "  ğŸ“¤ Discovery commands sent to %d devices, waiting for responses...", successful_sends);
    
    // å¿œç­”ã‚’å¾…æ©Ÿ
    auto wait_result = future.wait_for(std::chrono::milliseconds(timeout_ms));
    discovery_promise_ = nullptr;
    
    auto discovered = getDiscoveredMicrocontrollers();
    
    if (wait_result == std::future_status::timeout) {
        RCLCPP_WARN(this->get_logger(), "â° Discovery timeout after %dms. Found %zu microcontrollers", timeout_ms, discovered.size());
    } else {
        RCLCPP_INFO(this->get_logger(), "âœ… Discovery completed. Found %zu microcontrollers", discovered.size());
    }
    
    // ç™ºè¦‹ã•ã‚ŒãŸãƒã‚¤ã‚³ãƒ³ã‚’ãƒ­ã‚°å‡ºåŠ›
    for (const auto& mc : discovered) {
        RCLCPP_INFO(this->get_logger(), "  ğŸ”— Discovered: %s", mc.c_str());
    }
    
    // å‰å›ã¨çµæœãŒç•°ãªã‚‹å ´åˆã¯è­¦å‘Š
    if (discovered.size() != previous_microcontrollers.size()) {
        RCLCPP_WARN(this->get_logger(), "ğŸ“Š Microcontroller count changed: %zu -> %zu", 
                   previous_microcontrollers.size(), discovered.size());
    }
    
    return discovered;
}

std::vector<std::string> IntegratedCommunicationSystem::getDiscoveredMicrocontrollers() const {
    std::lock_guard<std::mutex> lock(discovery_mutex_);
    return discovered_microcontrollers_;
}

std::map<std::string, std::vector<std::string>> IntegratedCommunicationSystem::getNetworkMicrocontrollerMap() const {
    std::lock_guard<std::mutex> lock(node_map_mutex_);
    return node_to_microcontrollers_map_;
}

void IntegratedCommunicationSystem::sendToNodeAsync(
    const std::string& target_node, const std::string& final_destination,
    const std::vector<std::string>& data, const std::string& message, int64_t request_type)
{
    auto client = get_client(target_node);
    if (!client->service_is_ready()) { 
        RCLCPP_ERROR(this->get_logger(), "ã‚µãƒ¼ãƒ“ã‚¹ %s ãŒæº–å‚™ã•ã‚Œã¦ã„ã¾ã›ã‚“", target_node.c_str());
        return; 
    }

    auto request = std::make_shared<my_cpp_pkg::srv::DataExchange::Request>();
    request->request_type = request_type;
    request->source_node = self_node_name_;
    request->destination_node = final_destination;
    request->string_values = data;
    request->transaction_id = generate_transaction_id();
    request->message = message;
    
    RCLCPP_INFO(this->get_logger(), "éåŒæœŸé€ä¿¡é–‹å§‹: %s -> request_type=%ld, data_size=%zu", 
                target_node.c_str(), request_type, data.size());
    
    client->async_send_request(request);
    RCLCPP_INFO(this->get_logger(), "éåŒæœŸé€ä¿¡å®Œäº†: %s", target_node.c_str());
}

bool IntegratedCommunicationSystem::sendToMicrocontroller(const std::string& microcontroller_id, const std::string& data) {
    std::shared_ptr<SerialCommunication> serial_device = nullptr;
    {
        std::lock_guard<std::mutex> lock(discovery_mutex_);
        auto it = microcontroller_device_map_.find(microcontroller_id);
        if (it == microcontroller_device_map_.end()) {
            RCLCPP_ERROR(this->get_logger(), "ãƒã‚¤ã‚³ãƒ³ '%s' ã«å¯¾å¿œã™ã‚‹ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", microcontroller_id.c_str());
            return false;
        }
        serial_device = it->second;
    }
    return serial_device->sendRaw(data);
}

void IntegratedCommunicationSystem::handle_request(
    const std::shared_ptr<my_cpp_pkg::srv::DataExchange::Request> request,
    std::shared_ptr<my_cpp_pkg::srv::DataExchange::Response> response)
{
    RCLCPP_INFO(this->get_logger(), "ğŸ” ã‚µãƒ¼ãƒ“ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆå—ä¿¡: source=%s, request_type=%ld", 
                request->source_node.c_str(), request->request_type);
                
    if (request->request_type == 1) {
        // (ãƒã‚¤ã‚³ãƒ³ãƒªã‚¹ãƒˆè¦æ±‚ã®å‡¦ç†ã¯å¤‰æ›´ãªã—)
        RCLCPP_INFO(this->get_logger(), "ğŸ“‹ ãƒã‚¤ã‚¯ãƒ­ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒªã‚¹ãƒˆè¦æ±‚ã‚’å‡¦ç†ä¸­...");
        auto microcontroller_list = getDiscoveredMicrocontrollers();
        response->string_values = microcontroller_list;
        response->response_type = 101;
        response->return_node = self_node_name_;
        RCLCPP_INFO(this->get_logger(), "âœ… ãƒã‚¤ã‚¯ãƒ­ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒªã‚¹ãƒˆå¿œç­”: %zuå€‹", microcontroller_list.size());
        return;
    }

    if (request->request_type == 2) {
        std::string target_mc = request->destination_node;
        bool is_local = false;

        {
            std::lock_guard<std::mutex> lock(discovery_mutex_);
            if (microcontroller_device_map_.count(target_mc)) {
                is_local = true;
            }
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šç¾åœ¨ç™ºè¦‹ã•ã‚Œã¦ã„ã‚‹ãƒã‚¤ã‚³ãƒ³ã‚’ãƒ­ã‚°å‡ºåŠ›
            RCLCPP_DEBUG(this->get_logger(), "ğŸ“Š Current discovered microcontrollers:");
            for (const auto& mc : discovered_microcontrollers_) {
                RCLCPP_DEBUG(this->get_logger(), "  - %s", mc.c_str());
            }
        }

        RCLCPP_INFO(this->get_logger(), "ğŸ” (Type 2) Processing command for '%s', is_local=%s", 
                   target_mc.c_str(), is_local ? "true" : "false");

        if (is_local) {
            // â˜…â˜…â˜… é…åˆ—ã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã®æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¦ç›´æ¥ã‚·ãƒªã‚¢ãƒ«é€ä¿¡ â˜…â˜…â˜…
            RCLCPP_INFO(this->get_logger(), "ğŸ“¥ (Type 2) Local command for '%s'", target_mc.c_str());
            
            std::stringstream ss;
            const auto& data_array = request->string_values;
            for (size_t i = 0; i < data_array.size(); ++i) {
                ss << data_array[i] << (i == data_array.size() - 1 ? "" : ",");
            }
            ss << "|";
            std::string serial_string = ss.str();
            
            RCLCPP_INFO(this->get_logger(), "  -> Serial: %s", serial_string.c_str());
            bool sent = sendToMicrocontroller(target_mc, serial_string + "\n");
            response->response_type = sent ? 200 : 500;
        } else {
            // ä»–ãƒãƒ¼ãƒ‰ã¸ã®è»¢é€ï¼ˆè‡ªåˆ†è‡ªèº«ã¸ã®è»¢é€ã¯é™¤å¤–ï¼‰
            std::string forward_to_node;
            {
                std::lock_guard<std::mutex> lock(node_map_mutex_);
                for (const auto& pair : node_to_microcontrollers_map_) {
                    // è‡ªåˆ†è‡ªèº«ã®ãƒãƒ¼ãƒ‰ã¯é™¤å¤–
                    if (pair.first == self_node_name_) {
                        continue;
                    }
                    if (std::find(pair.second.begin(), pair.second.end(), target_mc) != pair.second.end()) {
                        forward_to_node = pair.first;
                        break;
                    }
                }
            }

            if (!forward_to_node.empty()) {
                RCLCPP_INFO(this->get_logger(), "â¡ï¸ (Type 2) Forwarding command for '%s' to node '%s'", target_mc.c_str(), forward_to_node.c_str());
                sendToNodeAsync(forward_to_node, request->destination_node, request->string_values, "", request->request_type);
                response->response_type = 202;
            } else {
                RCLCPP_ERROR(this->get_logger(), "âŒ (Type 2) Destination MC '%s' not found in network or only available locally.", target_mc.c_str());
                response->response_type = 404;
            }
        }
        
        response->return_node = self_node_name_;
        response->transaction_id = request->transaction_id;
        return;
    }

    if (request->request_type == 3) { // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒãƒƒãƒ•ã‚¡ã‹ã‚‰ã®å–å¾—
        RCLCPP_INFO(this->get_logger(), "ğŸ” (Type 3) Getting buffered messages");
        
        std::vector<std::string> buffered_messages;
        {
            std::lock_guard<std::mutex> lock(message_buffer_mutex_);
            while (!pending_messages_.empty()) {
                buffered_messages.push_back(pending_messages_.front());
                pending_messages_.pop();
            }
        }
        
        response->string_values = buffered_messages;
        response->response_type = 200;
        response->return_node = self_node_name_;
        response->transaction_id = request->transaction_id;
        
        RCLCPP_INFO(this->get_logger(), "ğŸ“¤ (Type 3) Returned %zu buffered messages", buffered_messages.size());
        return;
    }

    if (request->request_type == 102) { // ãƒã‚¤ã‚³ãƒ³ã‹ã‚‰ã®å¿œç­”å‡¦ç†
        if (data_handler_callback_) {
            data_handler_callback_(request);
        } else {
            RCLCPP_WARN(this->get_logger(), "ãƒ‡ãƒ¼ã‚¿ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");
        }
    } else { // ãã®ä»–ã®ã‚¿ã‚¤ãƒ—ã¯å¾“æ¥é€šã‚Šã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°
        {
            std::lock_guard<std::mutex> lock(queue_mutex_);
            request_queue_.push(request);
        }
        queue_cv_.notify_one();
    }
    
    response->response_type = 200;
    response->return_node = self_node_name_;
    response->transaction_id = request->transaction_id;
}

void IntegratedCommunicationSystem::processRequestQueue()
{
    while(!shutdown_flag_) {
        std::shared_ptr<my_cpp_pkg::srv::DataExchange::Request> request;
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            queue_cv_.wait(lock, [this]{ return !request_queue_.empty() || shutdown_flag_; });
            if (shutdown_flag_) return;
            request = request_queue_.front();
            request_queue_.pop();
        }

        const auto& req_data = request->string_values;
        if (req_data.size() < 5) continue;

        std::string destination_mc = req_data[2];
        std::stringstream ss;
        ss << req_data[0] << "," << req_data[1] << "," << req_data[2] << ","
           << request->transaction_id << "," << req_data[3] << ",";
        for (size_t i = 4; i < req_data.size(); ++i) {
            ss << req_data[i] << (i == req_data.size() - 1 ? "" : ",");
        }
        ss << "|";
        
        {
            std::lock_guard<std::mutex> lock(forward_map_mutex_);
            pending_forward_map_[request->transaction_id] = request->source_node;
        }

        RCLCPP_INFO(this->get_logger(), "ãƒã‚¤ã‚³ãƒ³ %s ã«ãƒ‡ãƒ¼ã‚¿é€ä¿¡: %s", destination_mc.c_str(), ss.str().c_str());
        bool sent = sendToMicrocontroller(destination_mc, ss.str() + "\n");
        RCLCPP_INFO(this->get_logger(), "é€ä¿¡çµæœ: %s", sent ? "æˆåŠŸ" : "å¤±æ•—");
    }
}

void IntegratedCommunicationSystem::handle_serial_data(const std::string& device_port, const std::string& raw_data) {
    RCLCPP_DEBUG(this->get_logger(), "ğŸ“¥ Received serial data from %s: '%s'", device_port.c_str(), raw_data.c_str());
    
    std::string data = raw_data;
    if (data.empty() || data.back() != '|') {
        RCLCPP_DEBUG(this->get_logger(), "âš ï¸ Invalid data format (no terminating '|'): '%s'", raw_data.c_str());
        return;
    }
    data.pop_back();

    std::vector<std::string> parts;
    std::stringstream ss(data);
    std::string item;
    while(std::getline(ss, item, ',')) parts.push_back(item);

    RCLCPP_DEBUG(this->get_logger(), "ğŸ“Š Parsed %zu parts from serial data", parts.size());
    for (size_t i = 0; i < parts.size(); ++i) {
        RCLCPP_DEBUG(this->get_logger(), "  Part[%zu]: '%s'", i, parts[i].c_str());
    }

    if (parts.size() >= 2 && parts[0] == "101") {
        RCLCPP_INFO(this->get_logger(), "ğŸ” Processing ID discovery response: ID=101");
        std::string mc_id = parts[1];
        RCLCPP_INFO(this->get_logger(), "    Microcontroller ID: '%s'", mc_id.c_str());
        bool newly_discovered = false;
        {
            std::lock_guard<std::mutex> lock(discovery_mutex_);
            if (std::find(discovered_microcontrollers_.begin(), discovered_microcontrollers_.end(), mc_id) == discovered_microcontrollers_.end()) {
                discovered_microcontrollers_.push_back(mc_id);
                for(const auto& dev : serial_comms_) {
                    if(dev->getPort() == device_port) {
                        microcontroller_device_map_[mc_id] = dev;
                        break;
                    }
                }
                newly_discovered = true;
            } else {
                RCLCPP_DEBUG(this->get_logger(), "    Microcontroller '%s' already discovered", mc_id.c_str());
            }
        }
        if (newly_discovered) {
            RCLCPP_INFO(this->get_logger(), "âœ… ãƒã‚¤ã‚³ãƒ³ID '%s' ã‚’ãƒãƒ¼ãƒˆ %s ã§ç™ºè¦‹ãƒ»ç™»éŒ²ã—ã¾ã—ãŸã€‚", mc_id.c_str(), device_port.c_str());
            if (discovery_promise_) { 
                RCLCPP_INFO(this->get_logger(), "ğŸ¯ Discovery promise fulfilled for '%s'", mc_id.c_str());
                discovery_promise_->set_value(true); 
            }
        }
        return;
    }

    if (parts.size() >= 4 && parts[0] == "102") {
        try {
            int64_t tid = std::stoll(parts[2]);
            std::string original_sender;
            {
                std::lock_guard<std::mutex> lock(forward_map_mutex_);
                if (pending_forward_map_.count(tid)) {
                    original_sender = pending_forward_map_[tid];
                    pending_forward_map_.erase(tid);
                    
                    std::vector<std::string> response_data(parts.begin(), parts.end());
                    sendToNodeAsync(original_sender, "PC2", response_data, "ãƒã‚¤ã‚³ãƒ³ã‹ã‚‰ã®å¿œç­”", 102);
                    return;
                }
            }
            {
                std::lock_guard<std::mutex> lock(microcontroller_relay_mutex_);
                if (microcontroller_pending_map_.count(tid)) {
                    original_sender = microcontroller_pending_map_[tid];
                    microcontroller_pending_map_.erase(tid);
                    
                    std::stringstream response_message;
                    for (size_t i = 0; i < parts.size(); ++i) {
                        if (i > 0) response_message << ",";
                        response_message << parts[i];
                    }
                    response_message << "|";
                    
                    sendToMicrocontroller(original_sender, response_message.str() + "\n");
                    return;
                }
            }
            RCLCPP_WARN(this->get_logger(), "TID %ld ã«å¯¾ã™ã‚‹å¾…æ©Ÿä¸­ã®è¦æ±‚ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", tid);
        } catch (const std::exception& e) {
            RCLCPP_ERROR(this->get_logger(), "TIDã®è§£æã«å¤±æ•—: %s", e.what());
        }
        return;
    }
    
    if (parts.size() == 3 && parts[0] == "1") {
        std::string target_node = parts[1];
        RCLCPP_INFO(this->get_logger(), "ğŸ›°ï¸ ãƒã‚¤ã‚³ãƒ³ã‹ã‚‰ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¢ç´¢è¦æ±‚: ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ='%s'", target_node.c_str());

        std::string source_mc_id = "unknown_mc";
        {
            std::lock_guard<std::mutex> lock(discovery_mutex_);
            for(const auto& pair : microcontroller_device_map_) {
                if (pair.second->getPort() == device_port) {
                    source_mc_id = pair.first;
                    break;
                }
            }
        }

        if (source_mc_id == "unknown_mc") {
            RCLCPP_ERROR(this->get_logger(), "ãƒãƒ¼ãƒˆ %s ã‹ã‚‰ã®è¦æ±‚ã§ã™ãŒã€é€ä¿¡å…ƒãƒã‚¤ã‚³ãƒ³ã‚’ç‰¹å®šã§ãã¾ã›ã‚“ã€‚", device_port.c_str());
            return;
        }

        std::vector<std::string> mc_list;
        {
            std::lock_guard<std::mutex> lock(node_map_mutex_);
            auto it = node_to_microcontrollers_map_.find(target_node);
            if (it != node_to_microcontrollers_map_.end()) {
                mc_list = it->second;
                RCLCPP_INFO(this->get_logger(), "ãƒãƒ¼ãƒ‰ '%s' ã«æ¥ç¶šã•ã‚ŒãŸãƒã‚¤ã‚³ãƒ³ %zu å€‹ã‚’ç™ºè¦‹ã€‚", target_node.c_str(), mc_list.size());
            } else {
                RCLCPP_WARN(this->get_logger(), "ãƒãƒ¼ãƒ‰ '%s' ã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒãƒƒãƒ—ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", target_node.c_str());
            }
        }

        std::stringstream response_ss;
        response_ss << "101," << self_node_name_ << "," << target_node << "," << mc_list.size();
        for(const auto& mc_name : mc_list) {
            response_ss << "," << mc_name;
        }
        response_ss << "|";
        
        RCLCPP_INFO(this->get_logger(), "ãƒã‚¤ã‚³ãƒ³ '%s' ã¸æ¢ç´¢çµæœã‚’è¿”ä¿¡: %s", source_mc_id.c_str(), response_ss.str().c_str());
        sendToMicrocontroller(source_mc_id, response_ss.str() + "\n");
        
        return;
    }
    
    // ID2ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°
    if (parts.size() >= 1 && parts[0] == "2") {
        RCLCPP_INFO(this->get_logger(), "ğŸ“¥ ID2ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°: %s", raw_data.c_str());
        {
            std::lock_guard<std::mutex> lock(message_buffer_mutex_);
            pending_messages_.push(raw_data);
        }
        return;
    }
    
    // ãƒã‚¤ã‚³ãƒ³ã‹ã‚‰é€ã‚‰ã‚Œã¦ããŸæ–‡å­—ã‚’ãã®ã¾ã¾PCã«é€ä¿¡
    if (data_handler_callback_) {
        std::string source_mc_id = "unknown_mc";
        {
             std::lock_guard<std::mutex> lock(discovery_mutex_);
             for(const auto& pair : microcontroller_device_map_) {
                 if (pair.second->getPort() == device_port) {
                     source_mc_id = pair.first;
                     break;
                 }
             }
        }
        
        // å…ƒã®ç”Ÿãƒ‡ãƒ¼ã‚¿ã‚’ãã®ã¾ã¾PCã«è»¢é€
        RCLCPP_INFO(this->get_logger(), "ğŸ“¤ ãƒã‚¤ã‚³ãƒ³ '%s' ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’PCã«è»¢é€: %s", source_mc_id.c_str(), raw_data.c_str());
        
        auto dummy_request = std::make_shared<my_cpp_pkg::srv::DataExchange::Request>();
        dummy_request->source_node = source_mc_id;
        dummy_request->string_values = parts;
        dummy_request->message = raw_data; // å…ƒã®æ–‡å­—åˆ—ã‚’ãã®ã¾ã¾ä¿å­˜
        data_handler_callback_(dummy_request);
    }
}

int64_t IntegratedCommunicationSystem::generate_transaction_id() { return distribution_(random_engine_); }

void IntegratedCommunicationSystem::setupAutomaticMicrocontrollerRelay() {
    setDataHandler([this](const std::shared_ptr<my_cpp_pkg::srv::DataExchange::Request> request) {
        this->handleMicrocontrollerToMicrocontrollerMessage(request);
    });
    RCLCPP_INFO(this->get_logger(), "ğŸ”— è‡ªå‹•ãƒã‚¤ã‚³ãƒ³é–“é€šä¿¡ä¸­ç¶™æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã—ã¾ã—ãŸ");
}

void IntegratedCommunicationSystem::handleMicrocontrollerToMicrocontrollerMessage(
    const std::shared_ptr<my_cpp_pkg::srv::DataExchange::Request> request) {
    
    const auto& data = request->string_values;
    if (data.size() < 4) { return; }
    
    std::string source_mc = data[1];
    std::string destination_mc = data[2];
    
    {
        std::lock_guard<std::mutex> lock(discovery_mutex_);
        if (microcontroller_device_map_.find(destination_mc) == microcontroller_device_map_.end()) {
            RCLCPP_WARN(this->get_logger(), "âŒ å®›å…ˆãƒã‚¤ã‚³ãƒ³ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", destination_mc.c_str());
            return;
        }
    }
    
    int64_t new_transaction_id = generate_transaction_id();
    
    std::stringstream relay_message;
    relay_message << data[0] << "," << data[1] << "," << data[2] << "," << new_transaction_id;
    for (size_t i = 4; i < data.size(); ++i) {
        relay_message << "," << data[i];
    }
    relay_message << "|";
    
    {
        std::lock_guard<std::mutex> lock(microcontroller_relay_mutex_);
        microcontroller_pending_map_[new_transaction_id] = source_mc;
    }
    
    bool sent = sendToMicrocontroller(destination_mc, relay_message.str() + "\n");
    if (!sent) {
        std::lock_guard<std::mutex> lock(microcontroller_relay_mutex_);
        microcontroller_pending_map_.erase(new_transaction_id);
    }
}

void IntegratedCommunicationSystem::startAutoDiscovery(int node_discovery_timeout_ms, int mc_discovery_timeout_ms) {
    RCLCPP_INFO(this->get_logger(), "ğŸš€ è‡ªå‹•æ¢ç´¢ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹ã—ã¾ã™...");
    
    // Step 1: è‡ªèº«ã«æ¥ç¶šã•ã‚ŒãŸãƒã‚¤ã‚¯ãƒ­ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚’æ¢ç´¢
    RCLCPP_INFO(this->get_logger(), "  (1/2) ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒã‚¤ã‚¯ãƒ­ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚’æ¢ç´¢ä¸­...");
    discoverMicrocontrollerIDs(mc_discovery_timeout_ms);
    auto local_mcs = getDiscoveredMicrocontrollers();
    {
        std::lock_guard<std::mutex> lock(node_map_mutex_);
        node_to_microcontrollers_map_[self_node_name_] = local_mcs;
    }
    RCLCPP_INFO(this->get_logger(), "  ãƒ­ãƒ¼ã‚«ãƒ«æ¢ç´¢å®Œäº†ã€‚%zuå€‹ã®ãƒã‚¤ã‚³ãƒ³ã‚’ç™ºè¦‹ã€‚", local_mcs.size());

    // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
    // â˜… ã“ã“ã«å¾…æ©Ÿå‡¦ç†ã‚’è¿½åŠ ã—ã¾ã™ â˜…
    // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
    RCLCPP_INFO(this->get_logger(), "  ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®å®‰å®šåŒ–ã®ãŸã‚1ç§’å¾…æ©Ÿã—ã¾ã™...");
    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Step 2: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã®ä»–ã®ãƒãƒ¼ãƒ‰ã¨ãã®ãƒã‚¤ã‚¯ãƒ­ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚’æ¢ç´¢
    RCLCPP_INFO(this->get_logger(), "  (2/2) ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã®ä»–ãƒãƒ¼ãƒ‰ã‚’æ¢ç´¢ä¸­...");
    discoverNodesAndTheirMicrocontrollers(node_discovery_timeout_ms);
    
    RCLCPP_INFO(this->get_logger(), "âœ¨ è‡ªå‹•æ¢ç´¢ãƒ—ãƒ­ã‚»ã‚¹å®Œäº†ã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å…¨ä½“ã®æ§‹æˆ:");
    auto network_map = getNetworkMicrocontrollerMap();
    for (const auto& pair : network_map) {
        std::string mc_list_str;
        if (pair.second.empty()) {
            mc_list_str = "(ãªã—)";
        } else {
            mc_list_str = std::accumulate(pair.second.begin(), pair.second.end(), std::string(),
                [](const std::string& a, const std::string& b) { return a.empty() ? b : a + ", " + b; });
        }
        RCLCPP_INFO(this->get_logger(), "  - Node[%s] -> MCs: [%s]", pair.first.c_str(), mc_list_str.c_str());
    }
}

void IntegratedCommunicationSystem::discoverNodesAndTheirMicrocontrollers(int timeout_ms) {
    std::vector<std::string> node_names;
    const int max_retries = 5;
    const auto retry_interval = std::chrono::milliseconds(500);

    for (int i = 0; i < max_retries; ++i) {
        node_names = this->get_node_names();
        
        std::string current_nodes_str = std::accumulate(node_names.begin(), node_names.end(), std::string(),
            [](const std::string& a, const std::string& b) { return a.empty() ? b : a + ", " + b; });
        RCLCPP_INFO(this->get_logger(), "  [æ¢ç´¢è©¦è¡Œ %d/%d] ç¾åœ¨èªè­˜ã—ã¦ã„ã‚‹ãƒãƒ¼ãƒ‰: [%s]", i + 1, max_retries, current_nodes_str.c_str());

        // è‡ªåˆ†è‡ªèº«ä»¥å¤–ã«1ã¤ã§ã‚‚ "æ„å‘³ã®ã‚ã‚‹" ãƒãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Œã°ç¶šè¡Œ
        // (è‡ªåˆ†è‡ªèº«ã¨ros2cliãƒ‡ãƒ¼ãƒ¢ãƒ³ä»¥å¤–ã®ãƒãƒ¼ãƒ‰ãŒ1ã¤ã§ã‚‚ã‚ã‚Œã°OK)
        long meaningful_nodes = std::count_if(node_names.begin(), node_names.end(), [this](const std::string& name) {
            return name != ("/" + this->self_node_name_) && name.find("_ros2cli_daemon") == std::string::npos;
        });
        if (meaningful_nodes > 0) {
            break;
        }

        if (i < max_retries - 1) {
             RCLCPP_INFO(this->get_logger(), "  ä»–ãƒãƒ¼ãƒ‰ãŒã¾ã è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å°‘ã—å¾…ã£ã¦å†è©¦è¡Œã—ã¾ã™...");
            std::this_thread::sleep_for(retry_interval);
        }
    }

    // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
    // â˜… ã“ã“ã‹ã‚‰ãŒä¿®æ­£ã•ã‚ŒãŸãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯ã§ã™ â˜…
    // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
    std::vector<std::string> target_nodes;
    std::string self_full_name = "/" + self_node_name_; // e.g., "/PC3"

    for (const auto& name : node_names) {
        // è‡ªåˆ†è‡ªèº«ã®ãƒãƒ¼ãƒ‰ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (name == self_full_name) {
            continue;
        }
        // ros2cliãŒå†…éƒ¨çš„ã«ä½¿ç”¨ã™ã‚‹ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒãƒ¼ãƒ‰ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (name.find("_ros2cli_daemon") != std::string::npos) {
            continue;
        }
        // ROS 2ã®å†…éƒ¨ã‚·ã‚¹ãƒ†ãƒ ãƒãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒƒãƒ— (ã‚ˆã‚Šå …ç‰¢ã«)
        if (name == "/rosout" || name == "/parameter_events") {
            continue;
        }
        
        // ä¸Šè¨˜ã®ã„ãšã‚Œã§ã‚‚ãªã‘ã‚Œã°ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒãƒ¼ãƒ‰ã¨ã—ã¦è¿½åŠ 
        // â˜…æ³¨æ„: get_node_names()ãŒè¿”ã™ã®ã¯ /PC1 ã®ã‚ˆã†ãªåå‰ãªã®ã§ã€/ ã‚’é™¤å»ã›ãšã«ãã®ã¾ã¾ä½¿ã†
        target_nodes.push_back(name.substr(1)); // å…ˆé ­ã®'/'ã‚’é™¤å»ã—ã¦ "PC1" ã®å½¢å¼ã§è¿½åŠ 
    }
    // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…

    if (target_nodes.empty()) {
        RCLCPP_INFO(this->get_logger(), "  æœ€çµ‚çš„ã«ä»–ãƒãƒ¼ãƒ‰ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ROSãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
        return;
    }

    RCLCPP_INFO(this->get_logger(), "  %zuå€‹ã®ä»–ãƒãƒ¼ãƒ‰ã‚’æ¤œå‡ºã€‚ã‚µãƒ¼ãƒ“ã‚¹ã‚’ç¢ºèªã—ã€ãƒã‚¤ã‚³ãƒ³ãƒªã‚¹ãƒˆã‚’è¦æ±‚ã—ã¾ã™...", target_nodes.size());

    using ServiceResponseFuture = rclcpp::Client<my_cpp_pkg::srv::DataExchange>::SharedFuture;
    std::map<std::string, ServiceResponseFuture> futures;

    for (const auto& node_name : target_nodes) {
        auto client = get_client(node_name);
        if (!client->wait_for_service(std::chrono::milliseconds(200))) { // å°‘ã—å¾…æ©Ÿæ™‚é–“ã‚’å¢—ã‚„ã™
            RCLCPP_WARN(this->get_logger(), "  ãƒãƒ¼ãƒ‰ '%s' ã®ã‚µãƒ¼ãƒ“ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", node_name.c_str());
            continue;
        }

        auto request = std::make_shared<my_cpp_pkg::srv::DataExchange::Request>();
        request->request_type = 1;
        request->source_node = self_node_name_;
        request->destination_node = node_name;
        request->transaction_id = generate_transaction_id();
        
        futures[node_name] = client->async_send_request(request).future.share();
    }

    auto start_time = std::chrono::steady_clock::now();
    for (auto& pair : futures) {
        const std::string& node_name = pair.first;
        auto& future = pair.second;
        
        auto time_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time);
        auto remaining_time = std::chrono::milliseconds(timeout_ms) - time_elapsed;
        if (remaining_time <= std::chrono::milliseconds(0)) break;

        if (future.wait_for(remaining_time) == std::future_status::ready) {
            auto response = future.get();
            if (response && response->response_type == 101) {
                std::lock_guard<std::mutex> lock(node_map_mutex_);
                node_to_microcontrollers_map_[node_name] = response->string_values;
            }
        } else {
            RCLCPP_WARN(this->get_logger(), "  ãƒãƒ¼ãƒ‰ '%s' ã‹ã‚‰ã®å¿œç­”ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚", node_name.c_str());
        }
    }
}




rclcpp::Client<my_cpp_pkg::srv::DataExchange>::SharedPtr IntegratedCommunicationSystem::get_client(const std::string &service_name) {
    if (clients_.find(service_name) == clients_.end()) {
        clients_[service_name] = this->create_client<my_cpp_pkg::srv::DataExchange>(service_name);
    }
    return clients_[service_name];
}

void IntegratedCommunicationSystem::monitoringLoop() {
    RCLCPP_INFO(this->get_logger(), "ğŸ”„ å®šæœŸçš„ãªãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¾ã—ãŸ");
    
    while (monitoring_enabled_ && !shutdown_flag_) {
        // 3ç§’é–“éš”ã§ç›£è¦–
        std::this_thread::sleep_for(std::chrono::seconds(3));
        
        if (!monitoring_enabled_ || shutdown_flag_) break;
        
        bool network_changed = detectNetworkChanges();
        bool serial_changed = detectSerialDeviceChanges();
        
        // ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ã®å®Ÿéš›ã®æ¥ç¶šçŠ¶æ…‹ã‚‚ãƒã‚§ãƒƒã‚¯
        bool serial_connection_issue = checkSerialConnectionHealth();
        
        if (network_changed || serial_changed || serial_connection_issue) {
            RCLCPP_INFO(this->get_logger(), "ğŸ”„ å¤‰æ›´ã‚’æ¤œå‡º: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯=%s, ã‚·ãƒªã‚¢ãƒ«=%s, æ¥ç¶šå•é¡Œ=%s - å†æ¢ç´¢ã‚’å®Ÿè¡Œã—ã¾ã™", 
                       network_changed ? "å¤‰æ›´ã‚ã‚Š" : "å¤‰æ›´ãªã—", 
                       serial_changed ? "å¤‰æ›´ã‚ã‚Š" : "å¤‰æ›´ãªã—",
                       serial_connection_issue ? "æ¤œå‡º" : "ãªã—");
            
            if (serial_changed || serial_connection_issue) {
                rescanSerialDevices();
                // ã‚·ãƒªã‚¢ãƒ«å•é¡ŒãŒã‚ã‚‹å ´åˆã®ã¿ã€å½±éŸ¿ã‚’å—ã‘ã‚‹ãƒã‚¤ã‚³ãƒ³ã®ãƒãƒƒãƒ—ã‚’éƒ¨åˆ†çš„ã«ã‚¯ãƒªã‚¢
                RCLCPP_INFO(this->get_logger(), "ğŸ”„ ã‚·ãƒªã‚¢ãƒ«å•é¡Œã«ã‚ˆã‚Šãƒã‚¤ã‚³ãƒ³æ¢ç´¢ã‚’å®Ÿè¡Œã—ã¾ã™");
                
                // å†æ¢ç´¢ã‚’å®Ÿè¡Œï¼ˆãƒã‚¤ã‚³ãƒ³ãƒãƒƒãƒ—ã¯ã‚¯ãƒªã‚¢ã—ãªã„ã€additive discoveryï¼‰
                discoverMicrocontrollerIDs(2000, false); // ã‚¯ãƒªã‚¢ã—ãªã„
                discoverNodesAndTheirMicrocontrollers(2000);
            } else {
                // å¤‰æ›´ãŒãªãã¦ã‚‚å®šæœŸçš„ã«æ¢ç´¢ã‚’å®Ÿè¡Œï¼ˆãƒã‚¤ã‚³ãƒ³ãƒãƒƒãƒ—ã¯ã‚¯ãƒªã‚¢ã—ãªã„ï¼‰
                RCLCPP_DEBUG(this->get_logger(), "ğŸ”„ å®šæœŸæ¢ç´¢ã‚’å®Ÿè¡Œä¸­...");
                discoverMicrocontrollerIDs(1000, false); // ã‚¯ãƒªã‚¢ã—ãªã„
            }
        }
    }
    
    RCLCPP_INFO(this->get_logger(), "ğŸ”„ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†ã—ã¾ã—ãŸ");
}

bool IntegratedCommunicationSystem::detectNetworkChanges() {
    std::vector<std::string> current_nodes = this->get_node_names();
    
    std::lock_guard<std::mutex> lock(monitoring_mutex_);
    
    // ãƒãƒ¼ãƒ‰æ•°ãŒå¤‰ã‚ã£ãŸå ´åˆ
    if (current_nodes.size() != last_known_nodes_.size()) {
        RCLCPP_INFO(this->get_logger(), "ğŸ“Š ãƒãƒ¼ãƒ‰æ•°ã®å¤‰åŒ–ã‚’æ¤œå‡º: %zu -> %zu", 
                   last_known_nodes_.size(), current_nodes.size());
        last_known_nodes_ = current_nodes;
        return true;
    }
    
    // ãƒãƒ¼ãƒ‰ã®å†…å®¹ãŒå¤‰ã‚ã£ãŸå ´åˆ
    std::sort(current_nodes.begin(), current_nodes.end());
    std::vector<std::string> sorted_last_nodes = last_known_nodes_;
    std::sort(sorted_last_nodes.begin(), sorted_last_nodes.end());
    
    if (current_nodes != sorted_last_nodes) {
        RCLCPP_INFO(this->get_logger(), "ğŸ“Š ãƒãƒ¼ãƒ‰æ§‹æˆã®å¤‰åŒ–ã‚’æ¤œå‡º");
        last_known_nodes_ = this->get_node_names(); // å…ƒã®é †åºã§ä¿å­˜
        return true;
    }
    
    return false;
}

bool IntegratedCommunicationSystem::detectSerialDeviceChanges() {
    std::vector<std::string> current_ports;
    for(const auto& dev : serial_comms_) {
        current_ports.push_back(dev->getPort());
    }
    
    std::lock_guard<std::mutex> lock(monitoring_mutex_);
    
    // ãƒãƒ¼ãƒˆæ•°ãŒå¤‰ã‚ã£ãŸå ´åˆ
    if (current_ports.size() != last_known_serial_ports_.size()) {
        RCLCPP_INFO(this->get_logger(), "ğŸ”Œ ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆæ•°ã®å¤‰åŒ–ã‚’æ¤œå‡º: %zu -> %zu", 
                   last_known_serial_ports_.size(), current_ports.size());
        last_known_serial_ports_ = current_ports;
        return true;
    }
    
    // ãƒãƒ¼ãƒˆã®å†…å®¹ãŒå¤‰ã‚ã£ãŸå ´åˆ
    std::sort(current_ports.begin(), current_ports.end());
    std::vector<std::string> sorted_last_ports = last_known_serial_ports_;
    std::sort(sorted_last_ports.begin(), sorted_last_ports.end());
    
    if (current_ports != sorted_last_ports) {
        RCLCPP_INFO(this->get_logger(), "ğŸ”Œ ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆæ§‹æˆã®å¤‰åŒ–ã‚’æ¤œå‡º");
        last_known_serial_ports_.clear();
        for(const auto& dev : serial_comms_) {
            last_known_serial_ports_.push_back(dev->getPort());
        }
        return true;
    }
    
    return false;
}

void IntegratedCommunicationSystem::rescanSerialDevices() {
    RCLCPP_INFO(this->get_logger(), "ğŸ”Œ ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ã®å†ã‚¹ã‚­ãƒ£ãƒ³ã‚’å®Ÿè¡Œä¸­...");
    
    // æ—¢å­˜ã®ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ã®å†æ¥ç¶šã‚’è©¦è¡Œ
    for (auto& dev : serial_comms_) {
        if (dev) {
            RCLCPP_INFO(this->get_logger(), "  ğŸ”„ %s ã®å†æ¥ç¶šã‚’è©¦è¡Œä¸­...", dev->getPort().c_str());
            
            if (!dev->isOpen() || !dev->checkConnection()) {
                RCLCPP_WARN(this->get_logger(), "  âš ï¸ %s ã«å•é¡ŒãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚å†æ¥ç¶šã‚’è©¦è¡Œã—ã¾ã™ã€‚", dev->getPort().c_str());
                
                if (dev->reconnect()) {
                    RCLCPP_INFO(this->get_logger(), "  âœ… %s ã®å†æ¥ç¶šã«æˆåŠŸã—ã¾ã—ãŸã€‚", dev->getPort().c_str());
                    
                    // å—ä¿¡ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å†è¨­å®š
                    dev->setReceiveCallback([this, port=dev->getPort()](const std::string& data){
                        this->handle_serial_data(port, data);
                    });
                    dev->startReceiving();
                } else {
                    RCLCPP_ERROR(this->get_logger(), "  âŒ %s ã®å†æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚", dev->getPort().c_str());
                }
            } else {
                RCLCPP_INFO(this->get_logger(), "  âœ… %s ã¯æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™ã€‚", dev->getPort().c_str());
            }
        }
    }
    
    // æ–°ã—ã„ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œç´¢ã‚‚è©¦è¡Œ
    std::vector<std::string> ports_to_scan = {"/dev/ttyACM0", "/dev/ttyACM1", "/dev/ttyUSB0", "/dev/ttyUSB1"};
    std::vector<std::string> existing_ports;
    
    for (const auto& dev : serial_comms_) {
        if (dev) {
            existing_ports.push_back(dev->getPort());
        }
    }
    
    // æ—¢å­˜ã®ãƒãƒ¼ãƒˆä»¥å¤–ã§æ–°ã—ã„ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œç´¢
    for (const auto& port : ports_to_scan) {
        if (std::find(existing_ports.begin(), existing_ports.end(), port) == existing_ports.end()) {
            RCLCPP_INFO(this->get_logger(), "  ğŸ” æ–°ã—ã„ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œç´¢ä¸­: %s", port.c_str());
            
            std::string node_name = "new_device_" + std::to_string(serial_comms_.size()) + "_node";
            auto new_device = std::make_shared<SerialCommunication>(node_name, port, B115200, "|");
            
            if (new_device->initialize()) {
                RCLCPP_INFO(this->get_logger(), "  âœ… æ–°ã—ã„ãƒ‡ãƒã‚¤ã‚¹ã‚’ç™ºè¦‹: %s", port.c_str());
                
                new_device->setReceiveCallback([this, port](const std::string& data){
                    this->handle_serial_data(port, data);
                });
                new_device->startReceiving();
                
                serial_comms_.push_back(new_device);
                
                // æ–°ã—ã„ãƒ‡ãƒã‚¤ã‚¹ã«å¯¾ã—ã¦ãƒã‚¤ã‚³ãƒ³æ¢ç´¢ã‚’å®Ÿè¡Œ
                std::string id_request_command = "1," + self_node_name_ + ",0,|";
                new_device->sendRaw(id_request_command);
            }
        }
    }
    
    RCLCPP_INFO(this->get_logger(), "ğŸ”Œ ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ã®å†ã‚¹ã‚­ãƒ£ãƒ³å®Œäº†ã€‚ç¾åœ¨ %zu å€‹ã®ãƒ‡ãƒã‚¤ã‚¹ãŒæ¥ç¶šã•ã‚Œã¦ã„ã¾ã™ã€‚", serial_comms_.size());
}

bool IntegratedCommunicationSystem::checkSerialConnectionHealth() {
    bool has_issues = false;
    
    // ç¾åœ¨ç™ºè¦‹ã•ã‚Œã¦ã„ã‚‹ãƒã‚¤ã‚³ãƒ³ã®æ•°ã‚’ãƒã‚§ãƒƒã‚¯
    size_t current_mc_count = 0;
    {
        std::lock_guard<std::mutex> lock(discovery_mutex_);
        current_mc_count = discovered_microcontrollers_.size();
    }
    
    // ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ã¯æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ãŒãƒã‚¤ã‚³ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
    if (serial_comms_.size() > 0 && current_mc_count == 0) {
        RCLCPP_WARN(this->get_logger(), "âš ï¸ ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ã¯æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™ãŒã€ãƒã‚¤ã‚³ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å†æ¢ç´¢ãŒå¿…è¦ã§ã™ã€‚");
        has_issues = true;
    }
    
    // å„ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ã®è©³ç´°ãªå¥åº·ãƒã‚§ãƒƒã‚¯
    for (const auto& dev : serial_comms_) {
        if (!dev) {
            continue;
        }
        
        if (!dev->isOpen()) {
            RCLCPP_WARN(this->get_logger(), "âš ï¸ ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ %s ã®æ¥ç¶šãŒå¤±ã‚ã‚Œã¦ã„ã¾ã™ã€‚", dev->getPort().c_str());
            has_issues = true;
        } else {
            // æ¥ç¶šãŒé–‹ã„ã¦ã„ã¦ã‚‚ã€å®Ÿéš›ã«é€šä¿¡å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            if (!dev->checkConnection()) {
                RCLCPP_WARN(this->get_logger(), "âš ï¸ ã‚·ãƒªã‚¢ãƒ«ãƒ‡ãƒã‚¤ã‚¹ %s ã¯é–‹ã„ã¦ã„ã¾ã™ãŒã€é€šä¿¡ã«å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚", dev->getPort().c_str());
                has_issues = true;
            }
        }
    }
    
    if (has_issues) {
        RCLCPP_WARN(this->get_logger(), "âš ï¸ ã‚·ãƒªã‚¢ãƒ«æ¥ç¶šã«å•é¡ŒãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚å†æ¥ç¶šã‚’è©¦è¡Œã—ã¾ã™ã€‚");
    }
    
    return has_issues;
}

std::shared_ptr<IntegratedCommunicationSystem> create_integrated_system(
    const std::string& node_name, bool use_serial, int baudrate, bool auto_discover)
{
    std::vector<std::shared_ptr<SerialCommunication>> serial_devices;
    if (use_serial) {
        speed_t speed = convert_baudrate(std::to_string(baudrate));
        serial_devices = SerialCommunication::scanAndConnectDevices(
            {"/dev/ttyACM0", "/dev/ttyACM1", "/dev/ttyUSB0", "/dev/ttyUSB1"}, speed, "|");
    }
    return std::make_shared<IntegratedCommunicationSystem>(node_name, serial_devices, auto_discover);
}
